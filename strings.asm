;=============================================================================
; Подпрограммы для работы со строками
;
; 24.02.2017
; 27.08.2017 доработки
; 27.08.2017 добавлена STR_TO_UINT16
;
;=============================================================================

.def WL   = r24
.def WH   = r25

;-----------------------------------------------------------------------------
; Сравнение строк
; Используются: r16*, r17*, X*, Z*
; Вход: X - указатель на строку в ОЗУ
;       Z - указатель на строку во Flash
; Выход: r16 результат сравнения
;        r16 = 0 - строки равны
;        r16 = 1 - строки не равны
;-----------------------------------------------------------------------------
STR_CMP:
			lpm		r16,Z+
			ld		r17,X+
			cp		r16,r17
			brne	STR_CMP_FAIL
			tst		r16
			breq	STR_CMP_SUCCESS
			rjmp	STR_CMP
STR_CMP_SUCCESS:
			ldi		r16,0	; строки равны
			ret
STR_CMP_FAIL:
			ldi		r16,1	; строки не равны
			ret



;-----------------------------------------------------------------------------
; Проверка принадлежности символа к буквам/цифрам
; Используются: r15*, r16*, r17
; Вход: r17
; Выход: r16
;        r16 = 0 - ложь
;        r16 = 1 - истина
;-----------------------------------------------------------------------------
IS_CHAR:
			rcall	IS_LETTER
			mov		r15,r16
			rcall	IS_DIGIT
			or		r16,r15
			ret


;-----------------------------------------------------------------------------
; Проверка принадлежности символа к буквам
; только латинские буквы
; Используются: r15*, r16*, r17
; Вход: r17
; Выход: r16
;        r16 = 0 - ложь
;        r16 = 1 - истина
;-----------------------------------------------------------------------------
IS_LETTER:
			rcall	IS_LOWER
			mov		r15,r16
			rcall	IS_UPPER
			or		r16,r15
			ret


;-----------------------------------------------------------------------------
; Проверка принадлежности символа к строчным (маленьким) буквам
; только латинские буквы
; Используются: r16*, r17
; Вход: r17
; Выход: r16
;        r16 = 0 - ложь
;        r16 = 1 - истина
;-----------------------------------------------------------------------------
IS_LOWER:
			clr		r16
			cpi		r17,0x61
			brlo	NON_LOWER	; перейти, если меньше
			cpi		r17,0x7b
			brsh	NON_LOWER	; перейти, если равно или больше
			ldi		r16,1
NON_LOWER:
			ret



;-----------------------------------------------------------------------------
; Проверка принадлежности символа к прописным (большим) буквам
; только латинские буквы
; Используются: r16*, r17
; Вход: r17
; Выход: r16
;        r16 = 0 - ложь
;        r16 = 1 - истина
;-----------------------------------------------------------------------------
IS_UPPER:
			clr		r16
			cpi		r17,0x41
			brlo	NON_UPPER	; перейти, если меньше
			cpi		r17,0x5b
			brsh	NON_UPPER	; перейти, если равно или больше
			ldi		r16,1
NON_UPPER:
			ret


;-----------------------------------------------------------------------------
; Проверка принадлежности символа к цифрам
; цифры лежат в диапазоне ASCII 0x30...0x39 включительно (0...9 соответственно)
; Используются: r16*, r17
; Вход: r17
; Выход: r16
;        r16 = 0 - ложь
;        r16 = 1 - истина
;-----------------------------------------------------------------------------
IS_DIGIT:
			; 0x30 =< r17 =< 0x39
			clr		r16
			cpi		r17,0x30	; 0x30 = '0'
			brlo	NON_DIGIT	; перейти, если меньше
			cpi		r17,0x3a
			brsh	NON_DIGIT	; перейти, если равно или больше
			ldi		r16,1
NON_DIGIT:
			ret


;-----------------------------------------------------------------------------
; Вычисление длины строки
; строка должна оканчиваться на 0 (zero-ended string)
; Признаком конца строки является символ 0
; Используются: r16*, r17, Y (восстан.)
; Вход: Y - указатель на строку в ОЗУ
; Выход: r16
;-----------------------------------------------------------------------------
STR_LEN:
			push	YL	; сохраняем указатель
			push	YH
			push	r17
			clr		r16
STR_LEN_LOOP:
			ld		r17,Y+
			tst		r17
			breq	STR_LEN_EXIT
			inc		r16
			rjmp	STR_LEN_LOOP
STR_LEN_EXIT:
			pop		r17
			pop		YH
			pop		YL	; восстанавливаем указатель
			ret


;-----------------------------------------------------------------------------
; Преобразование строки в число
; 0...65535
; Используются: r16*, r24*, r25*, r26*, r27*
; Вход: Y (0-ended строка)
; Выход: r25:r24, r13
;        r13 = 0 успешно
;        r13 = 1 не число
;        r13 = 2 слишком большое
;-----------------------------------------------------------------------------
.def tmpL = r22
.def tmpH = r23
STR_TO_UINT16:
			clr		r24			; Обнуляем результат
			clr		r25
			rcall	STR_LEN		; Определяем длину строки
			cpi		r16,1
			breq	STR_TO_UINT16_1DIGIT
			cpi		r16,2
			breq	STR_TO_UINT16_2DIGIT
			cpi		r16,3
			breq	STR_TO_UINT16_3DIGIT
			cpi		r16,4
			breq	STR_TO_UINT16_4DIGIT
			cpi		r16,5
			breq	STR_TO_UINT16_5DIGIT
			rjmp	STR_TO_UINT16_TOOBIG
;--------------------
STR_TO_UINT16_5DIGIT:
			ld		r17,Y+
			rcall	IS_DIGIT	; проверяем - цифра ли это
			tst		r16
			breq	STR_TO_UINT16_NONDIGIT
			subi	r17,'0'	; переводим ASCII код цтфры в число
			ldi		tmpL,low(10000)
			ldi		tmpH,high(10000)
STR_TO_UINT16_LOOP5:
			tst		r17
			breq	STR_TO_UINT16_4DIGIT
			add		WL,tmpL
			adc		WH,tmpH
			dec		r17
			rjmp	STR_TO_UINT16_LOOP5
;--------------------
STR_TO_UINT16_4DIGIT:
			ld		r17,Y+
			rcall	IS_DIGIT	; проверяем - цифра ли это
			tst		r16		
			breq	STR_TO_UINT16_NONDIGIT
			subi	r17,'0'	; переводим ASCII код цтфры в число
			ldi		tmpL,low(1000)
			ldi		tmpH,high(1000)
STR_TO_UINT16_LOOP4:
			tst		r17
			breq	STR_TO_UINT16_3DIGIT
			add		WL,tmpL
			adc		WH,tmpH
			dec		r17
			rjmp	STR_TO_UINT16_LOOP4
;--------------------
STR_TO_UINT16_3DIGIT:
			ld		r17,Y+
			rcall	IS_DIGIT	; проверяем - цифра ли это
			tst		r16		
			breq	STR_TO_UINT16_NONDIGIT
			subi	r17,'0'	; переводим ASCII код цтфры в число
			ldi		tmpL,100
			mul		r17,tmpL
			add		WL,r0
			adc		WH,r1
;--------------------
STR_TO_UINT16_2DIGIT:
			ld		r17,Y+
			rcall	IS_DIGIT	; проверяем - цифра ли это
			tst		r16		
			breq	STR_TO_UINT16_NONDIGIT
			subi	r17,'0'	; переводим ASCII код цтфры в число
			ldi		tmpL,10
			mul		r17,tmpL
			add		WL,r0
			adc		WH,r1
;--------------------
STR_TO_UINT16_1DIGIT:
			ld		r17,Y+
			rcall	IS_DIGIT	; проверяем - цифра ли это
			tst		r16		
			breq	STR_TO_UINT16_NONDIGIT
			subi	r17,'0'	; переводим ASCII код цтфры в число
			clr		tmpL
			add		WL,r17
			adc		WH,tmpL
			clr		r13		; статус - успех
			ret
STR_TO_UINT16_NONDIGIT:
			ldi		r16,1
			mov		r13,r16
			ret
STR_TO_UINT16_TOOBIG:
			ldi		r16,2
			mov		r13,r16
			ret
.undef tmpL
.undef tmpH



;-----------------------------------------------------------------------------
; Преобразование строки в число
; 0...255
; Используются: r13*, r16*, r17*, r24* Y*
; Вход: Y (0-ended строка)
; Выход: r24, r13
;        r13 = 0 успешно
;        r13 = 1 не число
;        r13 = 2 слишком большое
; ЗАМЕЧАНИЕ! Примитивный код. Надо улучшить.
;-----------------------------------------------------------------------------
STR_TO_UINT8:
			ld		r17,Y+
			tst		r17
			breq	str_end
			rcall	IS_DIGIT	; проверяем - цифра ли это
			tst		r16		
			breq	str_to_uint8_nondigit
			inc		r16			; подсчет длины числа
			rjmp	STR_TO_UINT8
str_end:
			; оказались здесь, значит длина числа подсчитана
			ld		r17,-Y	; считали /0 - символ конца строки

			ld		r17,-Y	; считали первую цифру - единицы
			subi	r17,'0'	; переводим ASCII код цифры в число
			mov		WL,r17	; результат - единицы
			dec		r16		; уменьшаем счетчик цифр
			tst		r16		; не кончились ли цифры?
			breq	str_to_uint8_finish

			ld		r17,-Y	; считали вторую цифру - десятки
			subi	r17,'0'	; переводим ASCII код цифры в число
			ldi		r18,10
			mul		r17,r18	; выполняем умножение на 10
			add		WL,r0	; прибавляем к результату десятки
			dec		r16		; уменьшаем счетчик цифр
			tst		r16		; не кончились ли цифры?
			breq	str_to_uint8_finish

			ld		r17,-Y	; считали третью цифру - сотни
			cpi		r17,3	; если три и больше - слишком много
			brsh	str_to_uint8_too_big
str_to_uint8_next:
			subi	r17,'0'	; переводим ASCII код цифры в число
			ldi		r18,100
			mul		r17,r18	; выполняем умножение на 100
			add		WL,r0	; прибавляем к результату сотни
			brcs	str_to_uint8_too_big
			dec		r16		; уменьшаем счетчик цифр
			tst		r16		; не кончились ли цифры?
			breq	str_to_uint8_finish
			; если оказались тут, значит
			; цифры так и не кончились - статус too big
str_to_uint8_too_big:
			ldi		r16,2
			mov		r13,r16
			ret
str_to_uint8_nondigit:
			ldi		r16,1
			mov		r13,r16
			ret
str_to_uint8_finish:
			clr		r13		; статус - успех
			ret

;------------------------------------------------------------------------------
; End of file
;------------------------------------------------------------------------------
